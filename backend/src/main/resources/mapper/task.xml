<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.demo.dao.TaskDao">

	<!-- 태스크 생성 -->
	<insert id="insert" parameterType="task">
		<selectKey keyProperty="taskId" resultType="int" order="BEFORE">
			SELECT nextval('task_seq')
		</selectKey>
		INSERT INTO task (task_id, column_id, title, description, position, created_at,
			assignee_no, priority, start_date, due_date, workflow_status)
		VALUES (#{taskId}, #{columnId}, #{title}, #{description, jdbcType=VARCHAR},
			#{position}, CURRENT_TIMESTAMP,
			#{assigneeNo, jdbcType=INTEGER}, #{priority, jdbcType=VARCHAR},
			COALESCE(#{startDate, jdbcType=DATE}, CURRENT_DATE),
			#{dueDate, jdbcType=DATE}, COALESCE(#{workflowStatus, jdbcType=VARCHAR}, 'WAITING'))
	</insert>

	<!-- 컬럼별 태스크 목록 -->
	<select id="listByColumn" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE t.column_id = #{columnId}
		ORDER BY t.position ASC
	</select>

	<!-- 전체 태스크 목록 -->
	<select id="listAll" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		LEFT JOIN member m ON t.assignee_no = m.no
		ORDER BY t.column_id, t.position ASC
	</select>

	<!-- 팀별 태스크 목록 -->
	<select id="listByTeam" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		JOIN columns c ON t.column_id = c.column_id
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE c.team_id = #{teamId}
		ORDER BY t.column_id, t.position ASC
	</select>

	<!-- 태스크 상세 -->
	<select id="content" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE t.task_id = #{taskId}
	</select>

	<!-- 태스크 수정 (전체 필드) -->
	<update id="update" parameterType="task">
		UPDATE task
		SET title = #{title},
			description = #{description, jdbcType=VARCHAR},
			assignee_no = #{assigneeNo, jdbcType=INTEGER},
			priority = #{priority, jdbcType=VARCHAR},
			start_date = #{startDate, jdbcType=DATE},
			due_date = #{dueDate, jdbcType=DATE}
		WHERE task_id = #{taskId}
	</update>

	<!-- 태스크 삭제 -->
	<delete id="delete" parameterType="int">
		DELETE FROM task WHERE task_id = #{taskId}
	</delete>

	<!-- 태스크 위치/컬럼 변경 -->
	<update id="updatePosition" parameterType="task">
		UPDATE task
		SET column_id = #{columnId}, position = #{position}
		WHERE task_id = #{taskId}
	</update>

	<!-- 컬럼 내 최대 position 조회 -->
	<select id="getMaxPosition" parameterType="int" resultType="int">
		SELECT COALESCE(MAX(position), 0) FROM task WHERE column_id = #{columnId}
	</select>

	<!-- 담당자별 태스크 목록 (task_assignee 테이블 기준) -->
	<select id="listByAssignee" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE t.task_id IN (
			SELECT ta.task_id FROM task_assignee ta WHERE ta.member_no = #{memberNo}
		)
		ORDER BY
			CASE t.priority
				WHEN 'CRITICAL' THEN 1
				WHEN 'HIGH' THEN 2
				WHEN 'MEDIUM' THEN 3
				WHEN 'LOW' THEN 4
			END,
			t.due_date NULLS LAST
	</select>

	<!-- 워크플로우 상태별 태스크 목록 (팀 내) -->
	<select id="listByStatusAndTeam" parameterType="map" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		JOIN columns c ON t.column_id = c.column_id
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE c.team_id = #{teamId}
		AND t.workflow_status = #{workflowStatus}
		ORDER BY
			CASE t.priority
				WHEN 'CRITICAL' THEN 1
				WHEN 'HIGH' THEN 2
				WHEN 'MEDIUM' THEN 3
				WHEN 'LOW' THEN 4
			END,
			t.due_date NULLS LAST
	</select>

	<!-- 워크플로우 상태 변경 -->
	<update id="updateWorkflowStatus" parameterType="task">
		UPDATE task
		SET workflow_status = #{workflowStatus}
		WHERE task_id = #{taskId}
	</update>

	<!-- 반려 처리 -->
	<update id="updateRejection" parameterType="task">
		UPDATE task
		SET workflow_status = 'REJECTED',
			rejection_reason = #{rejectionReason},
			rejected_at = CURRENT_TIMESTAMP,
			rejected_by = #{rejectedBy}
		WHERE task_id = #{taskId}
	</update>

	<!-- 담당자만 변경 -->
	<update id="updateAssignee" parameterType="task">
		UPDATE task
		SET assignee_no = #{assigneeNo, jdbcType=INTEGER}
		WHERE task_id = #{taskId}
	</update>

	<!-- 내 검증 대기 목록 (검증자로 배정된 REVIEW 상태 태스크) -->
	<select id="listPendingVerification" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		LEFT JOIN member m ON t.assignee_no = m.no
		JOIN task_verifier tv ON t.task_id = tv.task_id
		WHERE tv.member_no = #{memberNo}
		AND tv.approved = false
		AND t.workflow_status = 'REVIEW'
		ORDER BY
			CASE t.priority
				WHEN 'CRITICAL' THEN 1
				WHEN 'HIGH' THEN 2
				WHEN 'MEDIUM' THEN 3
				WHEN 'LOW' THEN 4
			END,
			t.created_at ASC
	</select>

	<!-- 캘린더용 날짜 범위 조회 (팀 내, 마감일 기준) -->
	<select id="listByDateRange" parameterType="map" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by
		FROM task t
		JOIN columns c ON t.column_id = c.column_id
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE c.team_id = #{teamId}
		AND t.due_date IS NOT NULL
		AND t.due_date BETWEEN #{startDate} AND #{endDate}
		ORDER BY t.due_date ASC, t.priority ASC
	</select>

	<!-- 날짜 변경 (타임라인용) -->
	<update id="updateDates" parameterType="task">
		UPDATE task
		SET start_date = #{startDate, jdbcType=DATE},
			due_date = #{dueDate, jdbcType=DATE}
		WHERE task_id = #{taskId}
	</update>

	<!-- 마감일 임박 태스크 조회 (N일 이내, 완료되지 않은 태스크) -->
	<select id="listTasksApproachingDeadline" parameterType="int" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by,
			c.team_id
		FROM task t
		JOIN columns c ON t.column_id = c.column_id
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE t.due_date IS NOT NULL
		AND t.due_date BETWEEN CURRENT_DATE AND CURRENT_DATE + #{daysAhead}
		AND t.workflow_status NOT IN ('DONE', 'DECLINED')
		ORDER BY t.due_date ASC
	</select>

	<!-- 마감일 초과 태스크 조회 (완료되지 않은 태스크) -->
	<select id="listOverdueTasks" resultType="task">
		SELECT t.task_id, t.column_id, t.title, t.description, t.position, t.created_at,
			t.assignee_no, m.name as assignee_name, t.priority, t.start_date, t.due_date,
			t.workflow_status, t.rejection_reason, t.rejected_at, t.rejected_by,
			c.team_id
		FROM task t
		JOIN columns c ON t.column_id = c.column_id
		LEFT JOIN member m ON t.assignee_no = m.no
		WHERE t.due_date IS NOT NULL
		AND t.due_date &lt; CURRENT_DATE
		AND t.workflow_status NOT IN ('DONE', 'DECLINED')
		ORDER BY t.due_date ASC
	</select>

</mapper>
